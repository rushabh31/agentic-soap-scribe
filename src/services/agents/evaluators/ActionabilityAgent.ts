
import { Agent } from '../Agent';
import { AgentState, EvaluationDimension, SOAPNote } from '@/types/agent';

const SYSTEM_PROMPT = `
You are an Actionability Assessment Agent in a healthcare contact center multi-agent system.
Your specialized role is to measure how well the documentation supports clinical decision-making.

You should evaluate:
1. Plan Specificity Score (PSS): Rating of how specific and implementable the plan section is
2. Follow-up Clarity Score (FCS): Rating of how clearly follow-up actions are specified

Provide numerical scores (0-10) and detailed explanations for your evaluations.
`;

export class ActionabilityAgent extends Agent {
  constructor() {
    super('actionability_evaluator', SYSTEM_PROMPT);
  }

  public async process(state: AgentState): Promise<AgentState> {
    if (!state.soapNote) {
      return this.sendMessage(state, 'all', 'Cannot evaluate - no SOAP note available');
    }
    
    // First evaluate the multi-agent SOAP note
    const multiAgentEvaluation = await this.evaluateSOAP(state, state.soapNote, 'multi-agent');
    
    // Use sequential SOAP note from previous evaluations if available
    let sequentialSOAP: SOAPNote;
    if (state.evaluationResults?.sequential?.soapNote) {
      // Use the sequential SOAP note that was generated by previous evaluator
      sequentialSOAP = state.evaluationResults.sequential.soapNote as SOAPNote;
    } else {
      // Generate a new sequential SOAP note
      sequentialSOAP = await this.generateSequentialSOAP(state);
    }
    
    // Evaluate the sequential SOAP note
    const sequentialEvaluation = await this.evaluateSOAP(state, sequentialSOAP, 'sequential');
    
    // Calculate overall quality scores
    const multiAgentOverall = this.calculateOverallQuality(state, 'multiAgent', multiAgentEvaluation);
    const sequentialOverall = this.calculateOverallQuality(state, 'sequential', sequentialEvaluation);
    
    // Update the state with the evaluations and overall scores
    const updatedState = {
      ...state,
      evaluationResults: {
        ...state.evaluationResults,
        multiAgent: {
          ...state.evaluationResults?.multiAgent,
          actionability: multiAgentEvaluation,
          overallQuality: multiAgentOverall
        },
        sequential: {
          ...state.evaluationResults?.sequential,
          actionability: sequentialEvaluation,
          soapNote: sequentialSOAP,
          overallQuality: sequentialOverall
        }
      }
    };
    
    // Send a message with the comparison
    const message = `Actionability evaluation complete. Multi-agent score: ${multiAgentEvaluation.score}/10. Sequential score: ${sequentialEvaluation.score}/10.
Overall quality: Multi-agent: ${multiAgentOverall.toFixed(1)}/10, Sequential: ${sequentialOverall.toFixed(1)}/10.`;
    
    return this.sendMessage(updatedState, 'all', message);
  }
  
  private calculateOverallQuality(state: AgentState, approach: 'multiAgent' | 'sequential', actionabilityScore: EvaluationDimension): number {
    // Get scores from other evaluations
    const results = state.evaluationResults?.[approach];
    
    if (!results) return actionabilityScore.score;
    
    // Calculate weighted average as specified in the paper
    // QualityScore = 0.3 × COMP + 0.3 × ACC + 0.2 × CREL + 0.2 × ACT
    // We'll use completeness and accuracy, and substitute clinical relevance with actionability if not available
    
    const completeness = results.completeness?.score || 0;
    const accuracy = results.accuracy?.score || 0;
    const clinicalRelevance = results.clinicalRelevance?.score || actionabilityScore.score; // Use actionability as fallback
    
    return 0.3 * completeness + 0.3 * accuracy + 0.2 * clinicalRelevance + 0.2 * actionabilityScore.score;
  }
  
  private async evaluateSOAP(state: AgentState, soapNote: any, approach: string): Promise<EvaluationDimension> {
    // Extract plan section specifically for actionability evaluation
    const planSection = soapNote.plan || '';
    
    // Generate prompt for evaluation
    const prompt = `
Please evaluate the actionability of the following ${approach} SOAP note based on the original transcript.
Assess the Plan Specificity Score (0-10) and the Follow-up Clarity Score (0-10).
Focus particularly on the Plan section, but consider the entire SOAP note for context.

Original transcript:
${state.transcript}

SOAP note to evaluate:
${Object.values(soapNote).join('\n\n')}

Plan section specifically:
${planSection}

Format your evaluation as valid JSON with the following structure:
{
  "planSpecificityScore": 0-10,
  "planSpecificityDetails": "",
  "followUpClarityScore": 0-10,
  "followUpClarityDetails": "",
  "actionableElements": [],
  "improvementSuggestions": [],
  "overallActionabilityScore": 0-10,
  "summary": ""
}
`;

    const evaluationResponse = await this.callLLM(prompt);
    
    // Parse the evaluation response
    let evaluation;
    try {
      evaluation = JSON.parse(evaluationResponse);
    } catch (error) {
      console.error(`Failed to parse ${approach} Actionability evaluation:`, error);
      return {
        score: 0,
        metrics: {
          planSpecificity: { score: 0, details: 'Evaluation failed' },
          followUpClarity: { score: 0, details: 'Evaluation failed' }
        }
      };
    }
    
    // Create the evaluation dimension
    const dimension: EvaluationDimension = {
      score: evaluation.overallActionabilityScore || 0,
      metrics: {
        planSpecificity: { 
          score: evaluation.planSpecificityScore || 0, 
          details: evaluation.planSpecificityDetails || '' 
        },
        followUpClarity: { 
          score: evaluation.followUpClarityScore || 0, 
          details: evaluation.followUpClarityDetails || '' 
        }
      }
    };
    
    return dimension;
  }
  
  private async generateSequentialSOAP(state: AgentState): Promise<SOAPNote> {
    // Simulate the sequential approach by generating a SOAP note directly from the transcript
    const prompt = `
You are simulating a sequential pipeline approach to generating a SOAP note directly from a transcript.
Please create a SOAP note based only on the following healthcare call transcript.
Include Subjective, Objective, Assessment, and Plan sections.

Transcript:
${state.transcript}

Format your response with clear section headings: SUBJECTIVE, OBJECTIVE, ASSESSMENT, and PLAN.
`;

    const soapResponse = await this.callLLM(prompt);
    
    // Parse the SOAP sections
    const sections = this.parseSOAPSections(soapResponse);
    
    return sections;
  }
  
  private parseSOAPSections(soapText: string): SOAPNote {
    // Initialize with empty sections
    const soapNote: SOAPNote = {
      subjective: '',
      objective: '',
      assessment: '',
      plan: ''
    };
    
    // Extract Subjective section
    const subjectiveMatch = soapText.match(/SUBJECTIVE:?([\s\S]*?)(?=OBJECTIVE:|$)/i);
    if (subjectiveMatch && subjectiveMatch[1]) {
      soapNote.subjective = subjectiveMatch[1].trim();
    }
    
    // Extract Objective section
    const objectiveMatch = soapText.match(/OBJECTIVE:?([\s\S]*?)(?=ASSESSMENT:|$)/i);
    if (objectiveMatch && objectiveMatch[1]) {
      soapNote.objective = objectiveMatch[1].trim();
    }
    
    // Extract Assessment section
    const assessmentMatch = soapText.match(/ASSESSMENT:?([\s\S]*?)(?=PLAN:|$)/i);
    if (assessmentMatch && assessmentMatch[1]) {
      soapNote.assessment = assessmentMatch[1].trim();
    }
    
    // Extract Plan section
    const planMatch = soapText.match(/PLAN:?([\s\S]*?)(?=$)/i);
    if (planMatch && planMatch[1]) {
      soapNote.plan = planMatch[1].trim();
    }
    
    return soapNote;
  }
}
