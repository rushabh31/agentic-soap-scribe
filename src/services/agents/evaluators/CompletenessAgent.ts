
import { Agent } from '../Agent';
import { AgentState, EvaluationDimension, SOAPNote } from '@/types/agent';

const SYSTEM_PROMPT = `
You are a Documentation Completeness Evaluator Agent in a healthcare contact center multi-agent system.
Your specialized role is to evaluate the comprehensiveness of information capture in SOAP notes.

You should evaluate:
1. Information Capture Rate (ICR): Percentage of key information elements captured in the SOAP note
2. Missing Information Score (MIS): Penalty for critical information omitted from the SOAP note

Provide numerical scores (0-10) and detailed explanations for your evaluations.
`;

export class CompletenessAgent extends Agent {
  constructor() {
    super('completeness_evaluator', SYSTEM_PROMPT);
  }

  public async process(state: AgentState): Promise<AgentState> {
    if (!state.soapNote) {
      return this.sendMessage(state, 'all', 'Cannot evaluate - no SOAP note available');
    }
    
    // First evaluate the multi-agent SOAP note
    const multiAgentEvaluation = await this.evaluateSOAP(state, state.soapNote, 'multi-agent');
    
    // Generate a sequential approach SOAP note for comparison (if not already available)
    let sequentialSOAP: SOAPNote;
    if (state.evaluationResults?.sequential?.accuracy) {
      // Use the sequential SOAP note that was generated by the ClinicalAccuracyAgent
      sequentialSOAP = {
        subjective: state.evaluationResults.sequential.soapNote?.subjective || '',
        objective: state.evaluationResults.sequential.soapNote?.objective || '',
        assessment: state.evaluationResults.sequential.soapNote?.assessment || '',
        plan: state.evaluationResults.sequential.soapNote?.plan || ''
      };
    } else {
      // Generate a new sequential SOAP note
      sequentialSOAP = await this.generateSequentialSOAP(state);
    }
    
    // Evaluate the sequential SOAP note
    const sequentialEvaluation = await this.evaluateSOAP(state, sequentialSOAP, 'sequential');
    
    // Update the state with the evaluations
    const updatedState = {
      ...state,
      evaluationResults: {
        ...state.evaluationResults,
        multiAgent: {
          ...state.evaluationResults?.multiAgent,
          completeness: multiAgentEvaluation
        },
        sequential: {
          ...state.evaluationResults?.sequential,
          completeness: sequentialEvaluation,
          soapNote: sequentialSOAP
        }
      }
    };
    
    // Send a message with the comparison
    const message = `Completeness evaluation complete. Multi-agent score: ${multiAgentEvaluation.score}/10. Sequential score: ${sequentialEvaluation.score}/10.`;
    
    return this.sendMessage(updatedState, 'all', message);
  }
  
  private async evaluateSOAP(state: AgentState, soapNote: any, approach: string): Promise<EvaluationDimension> {
    // Combine SOAP sections for evaluation
    const soapContent = Object.values(soapNote).join('\n\n');
    
    // Generate prompt for evaluation
    const prompt = `
Please evaluate the completeness of the following ${approach} SOAP note based on the original transcript.
Assess the Information Capture Rate (0-10) and the Missing Information Score (0-10, where 10 means no missing information).

Original transcript:
${state.transcript}

SOAP note to evaluate:
${soapContent}

Format your evaluation as valid JSON with the following structure:
{
  "informationCaptureRate": 0-10,
  "captureDetails": "",
  "missingInformationScore": 0-10,
  "missingDetails": "",
  "keyMissingElements": [],
  "overallCompletenessScore": 0-10,
  "summary": ""
}
`;

    const evaluationResponse = await this.callLLM(prompt);
    
    // Parse the evaluation response
    let evaluation;
    try {
      evaluation = JSON.parse(evaluationResponse);
    } catch (error) {
      console.error(`Failed to parse ${approach} Completeness evaluation:`, error);
      return {
        score: 0,
        metrics: {
          informationCapture: { score: 0, details: 'Evaluation failed' },
          missingInformation: { score: 0, details: 'Evaluation failed' }
        }
      };
    }
    
    // Create the evaluation dimension
    const dimension: EvaluationDimension = {
      score: evaluation.overallCompletenessScore || 0,
      metrics: {
        informationCapture: { 
          score: evaluation.informationCaptureRate || 0, 
          details: evaluation.captureDetails || '' 
        },
        missingInformation: { 
          score: evaluation.missingInformationScore || 0, 
          details: evaluation.missingDetails || '' 
        }
      }
    };
    
    return dimension;
  }
  
  private async generateSequentialSOAP(state: AgentState): Promise<SOAPNote> {
    // Simulate the sequential approach by generating a SOAP note directly from the transcript
    const prompt = `
You are simulating a sequential pipeline approach to generating a SOAP note directly from a transcript.
Please create a SOAP note based only on the following healthcare call transcript.
Include Subjective, Objective, Assessment, and Plan sections.

Transcript:
${state.transcript}

Format your response with clear section headings: SUBJECTIVE, OBJECTIVE, ASSESSMENT, and PLAN.
`;

    const soapResponse = await this.callLLM(prompt);
    
    // Parse the SOAP sections
    const sections = this.parseSOAPSections(soapResponse);
    
    return sections;
  }
  
  private parseSOAPSections(soapText: string): SOAPNote {
    // Initialize with empty sections
    const soapNote: SOAPNote = {
      subjective: '',
      objective: '',
      assessment: '',
      plan: ''
    };
    
    // Extract Subjective section
    const subjectiveMatch = soapText.match(/SUBJECTIVE:?([\s\S]*?)(?=OBJECTIVE:|$)/i);
    if (subjectiveMatch && subjectiveMatch[1]) {
      soapNote.subjective = subjectiveMatch[1].trim();
    }
    
    // Extract Objective section
    const objectiveMatch = soapText.match(/OBJECTIVE:?([\s\S]*?)(?=ASSESSMENT:|$)/i);
    if (objectiveMatch && objectiveMatch[1]) {
      soapNote.objective = objectiveMatch[1].trim();
    }
    
    // Extract Assessment section
    const assessmentMatch = soapText.match(/ASSESSMENT:?([\s\S]*?)(?=PLAN:|$)/i);
    if (assessmentMatch && assessmentMatch[1]) {
      soapNote.assessment = assessmentMatch[1].trim();
    }
    
    // Extract Plan section
    const planMatch = soapText.match(/PLAN:?([\s\S]*?)(?=$)/i);
    if (planMatch && planMatch[1]) {
      soapNote.plan = planMatch[1].trim();
    }
    
    return soapNote;
  }
}
